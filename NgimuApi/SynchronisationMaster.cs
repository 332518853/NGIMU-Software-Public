using System;
using System.Diagnostics;
using System.Net;
using System.Threading;
using Rug.Osc;

namespace NgimuApi
{
    /// <summary>
    /// Synchronisation master. This class cannot be inherited.
    /// </summary>
    /// <seealso cref="System.IDisposable" />
    public sealed class SynchronisationMaster : IDisposable
    {
        private readonly ManualResetEvent threadExited = new ManualResetEvent(true);
        private readonly OscSender sender;
        private bool shouldExit = false;

        /// <summary>
        /// The send UDP port. All slaves must be listening on this port.
        /// </summary>
        public readonly int Port;

        /// <summary>
        /// The send interval of synchronisation messages in milliseconds.
        /// </summary>
        public readonly int Interval;

        /// <summary>
        /// Initializes a new instance of the <see cref="SynchronisationMaster"/> class.
        /// </summary>
        /// <param name="port">The send UDP port. All slaves must be listening on this port.</param>
        /// <param name="interval">The send interval of synchronisation messages in milliseconds.</param>
        /// <exception cref="System.ArgumentOutOfRangeException">interval;Interval must be greater or equal to 1 milliseconds.</exception>
        /// <autogeneratedoc />
        public SynchronisationMaster(int port = 9000, int interval = 500)
        {
            if (interval < 1)
            {
                throw new ArgumentOutOfRangeException("interval", "Interval must be greater or equal to 1 milliseconds.");
            }

            Port = port;
            Interval = interval;

            sender = new OscSender(IPAddress.Broadcast, 0, port); //, 1, 1500); 
        }

        /// <summary>
        /// Starts the synchronisation service.
        /// </summary>
        public void Start()
        {
            shouldExit = false;

            threadExited.Reset();

            sender.Connect();

            Thread thread = new Thread(delegate ()
            {
                try
                {
                    // get the frequency of the stopwatch 
                    double stopwatchFrequency = Stopwatch.Frequency;

                    // calculate the stopwatch ticks to milliseconds 
                    double stopwatchFrequencyToMilliseconds = stopwatchFrequency / 1000;

                    long waitThreshold = (long)(stopwatchFrequencyToMilliseconds * 20);
                    long expectedLatency = (long)(stopwatchFrequencyToMilliseconds * 10);

                    long normalisedInterval = (long)(stopwatchFrequencyToMilliseconds * Interval);
                    long previousTimeStamp = Stopwatch.GetTimestamp();

                    OscMessage syncOscCommand = new OscMessage("/sync", OscTimeTag.Now);

                    while (shouldExit == false)
                    {
                        long currentTimeStamp = Stopwatch.GetTimestamp();

                        if (previousTimeStamp > currentTimeStamp - normalisedInterval)
                        {
                            long deltaTimeStamp = currentTimeStamp - previousTimeStamp;

                            long timeUntilNextSend = normalisedInterval - deltaTimeStamp;

                            // if there is enough time to use the thread join mechanism then do it.
                            if (timeUntilNextSend > waitThreshold)
                            {
                                Thread.CurrentThread.Join((int)((timeUntilNextSend - expectedLatency) / stopwatchFrequencyToMilliseconds));
                            }

                            continue;
                        }

                        previousTimeStamp = currentTimeStamp;

                        syncOscCommand.ToArray()[0] = OscTimeTag.Now;

                        sender.Send(syncOscCommand);
                    }
                }
                finally
                {
                    threadExited.Set();
                }
            });

            thread.Priority = ThreadPriority.Highest;
            thread.Name = "Synchronisation Master";

            thread.Start();
        }

        /// <summary>
        /// Stops the synchronisation service.
        /// </summary>
        public void Stop()
        {
            shouldExit = true;

            threadExited.WaitOne();

            sender.Close();
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting resources.
        /// </summary>
        public void Dispose()
        {
            Stop();

            sender.Dispose();
        }
    }
}
