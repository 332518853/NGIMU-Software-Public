using System;
using System.Collections;
using System.Collections.Generic;
using System.Net;
using System.Net.NetworkInformation;
using System.Threading;
using Rug.Osc.Ahoy;

namespace NgimuApi.SearchForConnections
{
    public class SearchForConnections : IDisposable, IEnumerable<ConnectionSearchResult>
    {
        public readonly ConnectionSearchTypes SearchTypes;

        public readonly int SendInterval;

        public readonly int Timeout;

        /// <summary>
        /// Enumerate only IP version 4 UDP connections.
        /// </summary>
        private readonly static bool OnlyIpV4 = true;

        private readonly List<ConnectionSearchResult> connectionSearchResults = new List<ConnectionSearchResult>();

        private readonly object autoConnectionInfoListSyncLock = new object();

        private readonly List<IAhoyQuery> queriesList = new List<IAhoyQuery>();

        private readonly object queriesListSyncLock = new object();

        private readonly AhoyQueryAllSerialPorts serialPortQuery = new AhoyQueryAllSerialPorts();

        private DateTime startTime;
        private bool neverSearchNetworkAdapters;

        public int Count { get { return connectionSearchResults.Count; } }

        public ConnectionSearchResult this[int index] { get { return connectionSearchResults[index]; } }

        public event Action<ConnectionSearchResult> DeviceDiscovered;

        public event Action<ConnectionSearchResult> DeviceExpired;

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchForConnections"/> class.
        /// </summary>
        /// <param name="search">The search.</param>
        /// <param name="timeout">The timeout in milliseconds.</param>
        /// <param name="sendInterval">The send interval in milliseconds.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for #ctor
        public SearchForConnections(ConnectionSearchTypes search = ConnectionSearchTypes.All, int timeout = 0, int sendInterval = 100)
        {
            SearchTypes = search;
            Timeout = timeout;
            SendInterval = sendInterval;

            serialPortQuery.SerialDeviceDiscovered += SerialDeviceDiscovered;
            serialPortQuery.SerialDeviceExpired += SerialDeviceExpired;
        }

        public int IndexOf(ConnectionSearchResult connectionSearchResult)
        {
            lock (autoConnectionInfoListSyncLock)
            {
                return connectionSearchResults.IndexOf(connectionSearchResult);
            }
        }

        /// <summary>
        /// Enumerate all available connections. Note: This method blocks until connections have been enumerated.
        /// </summary>
        /// <param name="autoConnectorSearchTypes">Search filter.</param>
        /// <param name="timeout">The maximum time before failure.</param>
        /// <param name="interval">Time out in milliseconds between each process iteration.</param>
        /// <returns>All available connections.</returns>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for EnumerateConnections
        public static ConnectionSearchResult[] EnumerateConnections(
            ConnectionSearchTypes autoConnectorSearchTypes = ConnectionSearchTypes.All, int timeout = 500, int interval = 100)
        {
            using (SearchForConnections autoConnector2 = new SearchForConnections(autoConnectorSearchTypes, timeout, interval))
            {
                autoConnector2.Search();

                autoConnector2.Sort();

                return autoConnector2.ToArray();
            }
        }

        public void BeginSearch()
        {
            EndSearch();

            startTime = DateTime.Now;

            lock (autoConnectionInfoListSyncLock)
            {
                connectionSearchResults.Clear();
            }

            lock (queriesListSyncLock)
            {
                if ((SearchTypes & ConnectionSearchTypes.Udp) == ConnectionSearchTypes.Udp)
                {
                    BeginSearchUdp();
                }

                if ((SearchTypes & ConnectionSearchTypes.Serial) == ConnectionSearchTypes.Serial)
                {
                    BeginSearchSerial();
                }
            }
        }

        public void Dispose()
        {
            EndSearch();
        }

        public void EndSearch()
        {
            lock (queriesListSyncLock)
            {
                EndSearchUdp();

                EndSearchSerial();
            }

            startTime = DateTime.MinValue;
        }

        public IEnumerator<ConnectionSearchResult> GetEnumerator()
        {
            return connectionSearchResults.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return (connectionSearchResults as IEnumerable).GetEnumerator();
        }

        public void Search()
        {
            if (Timeout <= 0)
            {
                throw new System.Exception("Cannot search with an infinite timeout.");
            }

            BeginSearch();

            WaitForCompletion();
        }

        public void Sort()
        {
            lock (autoConnectionInfoListSyncLock)
            {
                connectionSearchResults.Sort();
            }
        }

        public ConnectionSearchResult[] ToArray()
        {
            lock (autoConnectionInfoListSyncLock)
            {
                return connectionSearchResults.ToArray();
            }
        }

        public void WaitForCompletion()
        {
            if (Timeout <= 0)
            {
                throw new System.Exception("Cannot wait with an infinite timeout.");
            }

            try
            {
                DateTime endTime = startTime.AddMilliseconds(Timeout);

                double timeDelta = (endTime - startTime).TotalSeconds;

                int waitInterval = (int)(timeDelta * 1000d);

                if (waitInterval > 0)
                {
                    Thread.CurrentThread.Join(waitInterval);
                }
            }
            finally
            {
                EndSearch();
            }
        }

        private void BeginSearchSerial()
        {
            serialPortQuery.BeginSearch(SendInterval);
        }

        private void BeginSearchUdp()
        {
            queriesList.Add(AhoyQuery.CreateQuery());

            foreach (IAhoyQuery query in queriesList)
            {
                query.ServiceDiscovered += delegate (AhoyServiceInfo serviceInfo)
                {
                    NetworkInterface networkInterface = GetInterfaceFor(serviceInfo.NetworkAdapterIPAddress);

                    string adapterName = "Unknown adapter";

                    if (networkInterface != null)
                    {
                        adapterName = networkInterface.Description;
                    }

                    ConnectionSearchResult connectionSearchResult = new ConnectionSearchResult(serviceInfo.Descriptor,
                        new UdpConnectionInfo()
                        {
                            AdapterName = adapterName,
                            NetworkAdapter = networkInterface,
                            AdapterIPAddress = serviceInfo.NetworkAdapterIPAddress,
                            SendIPAddress = serviceInfo.Address,
                            SendPort = serviceInfo.SendPort,
                            ReceivePort = serviceInfo.ListenPort,
                        });

                    lock (autoConnectionInfoListSyncLock)
                    {
                        connectionSearchResults.Add(connectionSearchResult);
                    }

                    DeviceDiscovered?.Invoke(connectionSearchResult);
                };

                query.ServiceExpired += delegate (AhoyServiceInfo serviceInfo)
                {
                    NetworkInterface networkInterface = GetInterfaceFor(serviceInfo.NetworkAdapterIPAddress);

                    string adapterName = "Unknown adapter";

                    if (networkInterface != null)
                    {
                        adapterName = networkInterface.Description;
                    }

                    ConnectionSearchResult connectionSearchResult = new ConnectionSearchResult(serviceInfo.Descriptor,
                        new UdpConnectionInfo()
                        {
                            AdapterName = adapterName,
                            NetworkAdapter = networkInterface,
                            AdapterIPAddress = serviceInfo.NetworkAdapterIPAddress,
                            SendIPAddress = serviceInfo.Address,
                            SendPort = serviceInfo.SendPort,
                            ReceivePort = serviceInfo.ListenPort,
                        });

                    lock (autoConnectionInfoListSyncLock)
                    {
                        connectionSearchResults.Remove(connectionSearchResult);
                    }

                    DeviceExpired?.Invoke(connectionSearchResult);
                };

                query.BeginSearch(SendInterval);
            }
        }

        private void EndSearchSerial()
        {
            serialPortQuery.EndSearch();
        }

        private void EndSearchUdp()
        {
            foreach (IAhoyQuery query in queriesList)
            {
                query.EndSearch();
            }

            queriesList.Clear();
        }

        private NetworkInterface GetInterfaceFor(IPAddress networkAdapterIPAddress)
        {
            if (neverSearchNetworkAdapters == true)
            {
                return null;
            }

            try
            {
                foreach (NetworkInterface @interface in NetworkInterface.GetAllNetworkInterfaces())
                {
                    var ipProps = @interface.GetIPProperties();

                    foreach (var ip in ipProps.UnicastAddresses)
                    {
                        if (ip.Address.Equals(networkAdapterIPAddress) == true)
                        {
                            return @interface;
                        }
                    }
                }

            }
            catch (EntryPointNotFoundException ex)
            {
                // if this is caught then it means we are on android or such like 
                neverSearchNetworkAdapters = true;
            }

            return null;
        }

        private void SerialDeviceExpired(string serialNumber, SerialConnectionInfo obj)
        {
            ConnectionSearchResult connectionSearchResult = new ConnectionSearchResult(serialNumber, obj);

            lock (autoConnectionInfoListSyncLock)
            {
                connectionSearchResults.Remove(connectionSearchResult);
            }

            DeviceExpired?.Invoke(connectionSearchResult);
        }

        private void SerialDeviceDiscovered(string serialNumber, SerialConnectionInfo obj)
        {
            ConnectionSearchResult connectionSearchResult = new ConnectionSearchResult(serialNumber, obj);

            lock (autoConnectionInfoListSyncLock)
            {
                connectionSearchResults.Add(connectionSearchResult);
            }

            DeviceDiscovered?.Invoke(connectionSearchResult);
        }
    }
}